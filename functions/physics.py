# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bu2yZUgXO51groDQO5e-fqN334gVZt22
"""

import numpy as np

# ==========================================
# 1. KEPLER PROBLEM (Two-Body)
# ==========================================

def F_kepler(u, t, mu=1.0, epsilon=1e-12):
    """
    Defines the differential equations for a simple Keplerian orbit.

    Args:
        u: State vector [x, y, vx, vy]
        t: Time (unused here but required by solver signature)
        mu: Gravitational parameter (GM)
        epsilon: Softening factor to prevent division by zero

    Returns:
        Derivative vector [vx, vy, ax, ay]
    """
    x, y, vx, vy = u

    # Calculate radius (with softening for numerical safety)
    r_squared = x**2 + y**2 + epsilon**2
    r = np.sqrt(r_squared)
    r3 = r**3

    # Acceleration F = -mu * r / |r|^3
    ax = -mu * x / r3
    ay = -mu * y / r3

    return np.array([vx, vy, ax, ay])


# ==========================================
# 2. HARMONIC OSCILLATOR
# ==========================================

def F_oscillator(u, t):
    """
    Simple Harmonic Oscillator: x'' = -x
    Used for Milestone 3 convergence testing because exact solution is known.
    """
    x, v = u
    return np.array([v, -x])

def u_exact_oscillator(t, u0=None):
    """
    Exact solution for Harmonic Oscillator.
    Assumes default u0=[1, 0] if not provided.
    """
    if u0 is None:
        u0 = np.array([1.0, 0.0])

    x0, v0 = u0
    # x(t) = x0*cos(t) + v0*sin(t)
    x_t = x0 * np.cos(t) + v0 * np.sin(t)
    # v(t) = -x0*sin(t) + v0*cos(t)
    v_t = -x0 * np.sin(t) + v0 * np.cos(t)

    return np.array([x_t, v_t])


# ==========================================
# 3. KEPLER PROBLEM (N-body)
# ==========================================

def F_nbody(u, t, masses, G=1.0, epsilon=1e-12):
    """
    Computes derivatives for the N-body problem.
    
    Args:
        u: State vector [x1, y1, z1, ..., vx1, vy1, vz1, ...]
           Length is 2 * 3 * N.
        masses: List or array of masses for the N bodies.
    """
    N = len(masses)
    n_dims = 3 
    
    # Extract positions and velocities
    mid = N * n_dims
    r_flat = u[:mid]
    v_flat = u[mid:]
    
    # Reshape positions for easier distance calculation
    r = r_flat.reshape((N, n_dims))
    a = np.zeros_like(r)
    
    for i in range(N):
        for j in range(N):
            if i != j:
                dist_vec = r[j] - r[i]
                dist_mag = np.linalg.norm(dist_vec) + epsilon # Softening
                # Acceleration: a_i = sum( G * m_j * vec_r / r^3 )
                a[i] += G * masses[j] * dist_vec / (dist_mag**3)
    
    # Return [velocities, accelerations] flattened
    return np.concatenate((v_flat, a.flatten()))